Это простой эмулятор завода на Java<br>
<i>Использованные средства:</i> потоки, сокеты<br>
<br>
Есть два приложения: клиент и сервер<br><b>Клиент</b> представляет из себя терминал, куда пользователь может вводить команды и получать на них ответы - служебные сообщения и др.<br>
<b>Сервер</b> осуществляет обмен сообщениями с клиентом и содержит также всю бизнес-логику эмулятора завода, т.е. является адаптером между заводом и клиентской консолью. Завод является полностью самостоятельным пакетом и не зависит от сервера.<br>
<b>Логика взаимодействия:</b> клиент посылает команды с аргументами или без на сервер. Изначально сервер проверяет служебные команды. Так как пока что она всего одна ("help"), и в других нет необходимости, они не оформлялись отдельной абстракцией, а просто выполняется проверка на равенство строк. Далее сервер интерпретирует название команды как имя метода класса Manager, который является менеджером по управлению заводом. Через рефлексию этот метод вызывается с одним аргументом в виде массива параметров, а в случае исключительной ситуации посылается соответствующее сообщение в терминал.<br>
<b>Это всё, что касается части, посвящённой сокетам.</b> В будущем, по необходимости, можно реализовать передачу сообщений в формате xml или json для большего единообразия.<br><br>
<b>Класс Manager</b> устроен следующим образом: есть Map производителей (семейство классов AbstractProducer), Map потребителей (класс TaskConsumer), а также хранилище (класс TaskStorage). Есть методы, позволяющие добавлять/удалять производителей/потребителей, а также полностью перезапускать систему.<br>
<b>Класс TaskStorage</b> является volatile synchronized контейнером с интерфейсом PutTask и GetTask.<br>
<b>Классы TaskConsumer и AbstractProducer</b> являются наследниками <b>AbstractTasker</b>, который реализует интерфейс Runnable содержит основные поля, необходимые потомкам. Каждый потомок совершает свою активность с промежутком в SleepTime благодаря тому, что каждый оформлен как отдельный поток<br>
<b>TaskConsumer</b> просто берёт задачу из хранилища и выполняет её.<br>
<b>AbstractProducer</b> содержит абстрактный метод ProduceNewTask, который должен создавать по определённой логике новые задачи. Как это делать - задача потомков. В качестве примера реализованы простые классы SimpleTaskProducer и OneTaskProducer, экземпляры каждого из которых можно создавать в менеджере (также при помощи рефлексии).<br>
На сервере выводится вся активность, связанная с заводом и не входящая в логику взаимодействия пользователя с приложением.<br><br>
